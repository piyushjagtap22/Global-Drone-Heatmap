"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deduceTableSchema = deduceTableSchema;

var _type2 = require("../types/arrow-like/type");

var _schema = _interopRequireDefault(require("./schema"));

var _field = _interopRequireDefault(require("./field"));

var TYPED_ARRAY_TO_TYPE = {
  Int8Array: new _type2.Int8(),
  Int16Array: new _type2.Int16(),
  Int32Array: new _type2.Int32(),
  Uint8Array: new _type2.Uint8(),
  Uint8ClampedArray: new _type2.Uint8(),
  Uint16Array: new _type2.Uint16(),
  Uint32Array: new _type2.Uint32(),
  Float32Array: new _type2.Float32(),
  Float64Array: new _type2.Float64()
};

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TO_TYPE.BigInt64Array = new _type2.Int64();
  TYPED_ARRAY_TO_TYPE.BigUint64Array = new _type2.Uint64();
}

function getTypeFromColumnArray(columnArray) {
  var ArrayType = columnArray.constructor && columnArray.constructor.name;
  var type = TYPED_ARRAY_TO_TYPE[ArrayType];

  if (type) {
    return {
      type: type,
      nullable: false,
      metadata: null
    };
  }

  var metadata = null;

  if (columnArray.length > 0) {
    var value = columnArray[0];
    type = deduceTypeFromValue(value);

    if (type) {
      metadata = new Map([['type', type.toString()]]);
    }
  }

  return {
    type: new _type2.Null(),
    nullable: true,
    metadata: metadata
  };
}

function deduceTableSchema(table) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  var fields = [];

  for (var columnName in columnarTable) {
    var columnArray = columnarTable[columnName];

    var _getTypeFromColumnArr = getTypeFromColumnArray(columnArray),
        type = _getTypeFromColumnArr.type,
        nullable = _getTypeFromColumnArr.nullable,
        metadata = _getTypeFromColumnArr.metadata;

    fields.push(new _field["default"](columnName, type, nullable, metadata || new Map()));
  }

  return new _schema["default"](fields);
}

function deduceSchemaForRowTable(rowTable) {
  var fields = [];

  if (rowTable.length) {
    var row = rowTable[0];

    if (Array.isArray(row)) {
      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {
        var value = row[columnIndex];
        var name = String(columnIndex);
        var type = deduceTypeFromValue(value);
        var nullable = true;
        var metadata = new Map([['type', type.toString()]]);
        fields.push(new _field["default"](name, new _type2.Null(), nullable, metadata));
      }
    } else {
      for (var columnName in row) {
        var _value = row[columnName];

        var _type = deduceTypeFromValue(_value);

        var _nullable = true;

        var _metadata = new Map([['type', _type.toString()]]);

        fields.push(new _field["default"](columnName, new _type2.Null(), _nullable, _metadata));
      }
    }
  }

  return new _schema["default"](fields);
}

function deduceTypeFromValue(value) {
  if (value === true || value === false) {
    return new _type2.Bool();
  }

  if (value instanceof Date) {
    return new _type2.TimestampMillisecond();
  }

  if (value instanceof Number) {
    return new _type2.Float32();
  }

  if (typeof value === 'string') {
    return new _type2.Utf8();
  }

  return new _type2.Null();
}
//# sourceMappingURL=schema-utils.js.map