import { Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float32, Float64, Bool, Utf8, TimestampMillisecond, Null } from '../types/arrow-like/type';
import Schema from './schema';
import Field from './field';
const TYPED_ARRAY_TO_TYPE = {
  Int8Array: new Int8(),
  Int16Array: new Int16(),
  Int32Array: new Int32(),
  Uint8Array: new Uint8(),
  Uint8ClampedArray: new Uint8(),
  Uint16Array: new Uint16(),
  Uint32Array: new Uint32(),
  Float32Array: new Float32(),
  Float64Array: new Float64()
};

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();
  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();
}

function getTypeFromColumnArray(columnArray) {
  const ArrayType = columnArray.constructor && columnArray.constructor.name;
  let type = TYPED_ARRAY_TO_TYPE[ArrayType];

  if (type) {
    return {
      type,
      nullable: false,
      metadata: null
    };
  }

  let metadata = null;

  if (columnArray.length > 0) {
    const value = columnArray[0];
    type = deduceTypeFromValue(value);

    if (type) {
      metadata = new Map([['type', type.toString()]]);
    }
  }

  return {
    type: new Null(),
    nullable: true,
    metadata
  };
}

export function deduceTableSchema(table, schema = null) {
  const deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  const fields = [];

  for (const columnName in columnarTable) {
    const columnArray = columnarTable[columnName];
    const {
      type,
      nullable,
      metadata
    } = getTypeFromColumnArray(columnArray);
    fields.push(new Field(columnName, type, nullable, metadata || new Map()));
  }

  return new Schema(fields);
}

function deduceSchemaForRowTable(rowTable) {
  const fields = [];

  if (rowTable.length) {
    const row = rowTable[0];

    if (Array.isArray(row)) {
      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {
        const value = row[columnIndex];
        const name = String(columnIndex);
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new Field(name, new Null(), nullable, metadata));
      }
    } else {
      for (const columnName in row) {
        const value = row[columnName];
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new Field(columnName, new Null(), nullable, metadata));
      }
    }
  }

  return new Schema(fields);
}

function deduceTypeFromValue(value) {
  if (value === true || value === false) {
    return new Bool();
  }

  if (value instanceof Date) {
    return new TimestampMillisecond();
  }

  if (value instanceof Number) {
    return new Float32();
  }

  if (typeof value === 'string') {
    return new Utf8();
  }

  return new Null();
}
//# sourceMappingURL=schema-utils.js.map