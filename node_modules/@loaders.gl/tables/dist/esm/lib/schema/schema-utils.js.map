{"version":3,"sources":["../../../../src/lib/schema/schema-utils.js"],"names":["Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Float32","Float64","Bool","Utf8","TimestampMillisecond","Null","Schema","Field","TYPED_ARRAY_TO_TYPE","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","getTypeFromColumnArray","columnArray","ArrayType","constructor","name","type","nullable","metadata","length","value","deduceTypeFromValue","Map","toString","deduceTableSchema","table","schema","deducedSchema","Array","isArray","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","assign","columnarTable","fields","columnName","push","rowTable","row","columnIndex","String","Date","Number"],"mappings":"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","sourcesContent":["// SCHEMA SUPPORT - AUTODEDUCTION\nimport {\n  // Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  // Float,\n  // Float16,\n  Float32,\n  Float64,\n  Bool,\n  Utf8,\n  TimestampMillisecond,\n  Null\n} from '../types/arrow-like/type';\nimport Schema from './schema';\nimport Field from './field';\n\nconst TYPED_ARRAY_TO_TYPE = {\n  Int8Array: new Int8(),\n  Int16Array: new Int16(),\n  Int32Array: new Int32(),\n  Uint8Array: new Uint8(),\n  Uint8ClampedArray: new Uint8(),\n  Uint16Array: new Uint16(),\n  Uint32Array: new Uint32(),\n  Float32Array: new Float32(),\n  Float64Array: new Float64()\n};\n\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n}\n\n// Type deduction\n\n/**\n * Type deduction from columnar array\n *\n * Notes:\n * - If the column is a typed array we are able to make a fairly precise type deduction\n * - However we can't tell if it is intervals, dates, fixed size lists etc.\n * - Nullable typed arrays are only supported if backing table is Arrow\n *\n * @param {*} columnArray\n * @returns type, nullable, metadata - (Arrow-like) type information\n */\nfunction getTypeFromColumnArray(columnArray) {\n  const ArrayType = columnArray.constructor && columnArray.constructor.name;\n  let type = TYPED_ARRAY_TO_TYPE[ArrayType];\n  if (type) {\n    return {type, nullable: false, metadata: null};\n  }\n\n  let metadata = null;\n  if (columnArray.length > 0) {\n    const value = columnArray[0];\n    type = deduceTypeFromValue(value);\n    if (type) {\n      metadata = new Map([['type', type.toString()]]);\n    }\n  }\n\n  // We use fields of Arrow-Type Null to indicate that we represent additional, non binary columns\n  return {type: new Null(), nullable: true, metadata};\n}\n\nexport function deduceTableSchema(table, schema = null) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const fields = [];\n  for (const columnName in columnarTable) {\n    const columnArray = columnarTable[columnName];\n    const {type, nullable, metadata} = getTypeFromColumnArray(columnArray);\n    fields.push(new Field(columnName, type, nullable, metadata || new Map()));\n  }\n  return new Schema(fields);\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const fields = [];\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // Note - handle rows in both array and object format\n    if (Array.isArray(row)) {\n      // row: [value1, value2, ...]\n      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        const value = row[columnIndex];\n        const name = String(columnIndex);\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(name, new Null(), nullable, metadata));\n      }\n    } else {\n      for (const columnName in row) {\n        // row: {columnName1: value1, columnName2: value2, ...}\n        // TODO - Could look at additional rows if nulls in first row\n        const value = row[columnName];\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(columnName, new Null(), nullable, metadata));\n      }\n    }\n  }\n  return new Schema(fields);\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value === true || value === false) {\n    return new Bool();\n  }\n  if (value instanceof Date) {\n    return new TimestampMillisecond();\n  }\n  if (value instanceof Number) {\n    return new Float32();\n  }\n  if (typeof value === 'string') {\n    return new Utf8();\n  }\n  // TODO JS columns (arrays and object valued) are currently null\n  return new Null();\n}\n"],"file":"schema-utils.js"}