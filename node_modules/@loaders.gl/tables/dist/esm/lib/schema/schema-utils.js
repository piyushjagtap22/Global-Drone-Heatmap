import { Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float32, Float64, Bool, Utf8, TimestampMillisecond, Null } from '../types/arrow-like/type';
import Schema from './schema';
import Field from './field';
var TYPED_ARRAY_TO_TYPE = {
  Int8Array: new Int8(),
  Int16Array: new Int16(),
  Int32Array: new Int32(),
  Uint8Array: new Uint8(),
  Uint8ClampedArray: new Uint8(),
  Uint16Array: new Uint16(),
  Uint32Array: new Uint32(),
  Float32Array: new Float32(),
  Float64Array: new Float64()
};

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();
  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();
}

function getTypeFromColumnArray(columnArray) {
  var ArrayType = columnArray.constructor && columnArray.constructor.name;
  var type = TYPED_ARRAY_TO_TYPE[ArrayType];

  if (type) {
    return {
      type: type,
      nullable: false,
      metadata: null
    };
  }

  var metadata = null;

  if (columnArray.length > 0) {
    var value = columnArray[0];
    type = deduceTypeFromValue(value);

    if (type) {
      metadata = new Map([['type', type.toString()]]);
    }
  }

  return {
    type: new Null(),
    nullable: true,
    metadata: metadata
  };
}

export function deduceTableSchema(table) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  var fields = [];

  for (var columnName in columnarTable) {
    var columnArray = columnarTable[columnName];

    var _getTypeFromColumnArr = getTypeFromColumnArray(columnArray),
        type = _getTypeFromColumnArr.type,
        nullable = _getTypeFromColumnArr.nullable,
        metadata = _getTypeFromColumnArr.metadata;

    fields.push(new Field(columnName, type, nullable, metadata || new Map()));
  }

  return new Schema(fields);
}

function deduceSchemaForRowTable(rowTable) {
  var fields = [];

  if (rowTable.length) {
    var row = rowTable[0];

    if (Array.isArray(row)) {
      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {
        var value = row[columnIndex];
        var name = String(columnIndex);
        var type = deduceTypeFromValue(value);
        var nullable = true;
        var metadata = new Map([['type', type.toString()]]);
        fields.push(new Field(name, new Null(), nullable, metadata));
      }
    } else {
      for (var columnName in row) {
        var _value = row[columnName];

        var _type = deduceTypeFromValue(_value);

        var _nullable = true;

        var _metadata = new Map([['type', _type.toString()]]);

        fields.push(new Field(columnName, new Null(), _nullable, _metadata));
      }
    }
  }

  return new Schema(fields);
}

function deduceTypeFromValue(value) {
  if (value === true || value === false) {
    return new Bool();
  }

  if (value instanceof Date) {
    return new TimestampMillisecond();
  }

  if (value instanceof Number) {
    return new Float32();
  }

  if (typeof value === 'string') {
    return new Utf8();
  }

  return new Null();
}
//# sourceMappingURL=schema-utils.js.map