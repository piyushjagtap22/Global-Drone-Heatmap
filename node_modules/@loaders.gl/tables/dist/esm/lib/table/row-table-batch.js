import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  batchSize: 'auto',
  convertToObject: true,
  optimizeMemoryUsage: false
};

var RowTableBatch = function () {
  function RowTableBatch(schema) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, RowTableBatch);

    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
    this.schema = schema;
    this.batchSize = options.batchSize;
    this.convertToObject = options.convertToObject;
    this.optimizeMemoryUsage = options.optimizeMemoryUsage;
    this.rows = null;
    this.length = 0;
    this.isChunkComplete = false;
    this.cursor = 0;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  _createClass(RowTableBatch, [{
    key: "addRow",
    value: function addRow(row) {
      var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!this.rows) {
        this.rows = new Array(this.batchSize);
        this.length = 0;
      }

      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      var convertToObject = this.convertToObject && this.schema;
      this.rows[this.length] = convertToObject ? convertRowToObject(row, this._headers) : row;

      if (this.optimizeMemoryUsage) {
        this.rows[this.length] = JSON.parse(JSON.stringify(this.rows[this.length]));
      }

      this.length++;
    }
  }, {
    key: "chunkComplete",
    value: function chunkComplete() {
      this.isChunkComplete = true;
    }
  }, {
    key: "isFull",
    value: function isFull() {
      if (this.batchSize === 'auto') {
        return this.isChunkComplete && this.length > 0;
      }

      return this.rows && this.length >= this.batchSize;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      if (this.rows) {
        var rows = this.rows.slice(0, this.length);
        this.rows = null;
        this.isChunkComplete = false;
        return {
          data: rows,
          schema: this.schema,
          length: rows.length,
          cursor: this.cursor
        };
      }

      return null;
    }
  }]);

  return RowTableBatch;
}();

export { RowTableBatch as default };

function convertRowToObject(row, headers) {
  if (!row) {
    throw new Error('null row');
  }

  if (!Array.isArray(row)) {
    return row;
  }

  if (!headers) {
    return row;
  }

  var result = {};

  for (var i = 0; i < headers.length; i++) {
    result[headers[i]] = row[i];
  }

  return result;
}
//# sourceMappingURL=row-table-batch.js.map