import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";

var ColumnarTableBatch = function () {
  function ColumnarTableBatch(schema) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ColumnarTableBatch);

    this.schema = schema;
    this.batchSize = options.batchSize || 'auto';
    this.length = 0;
    this.allocated = 0;
    this.columns = null;
    this.isChunkComplete = false;
    this.reallocateColumns();
  }

  _createClass(ColumnarTableBatch, [{
    key: "addRow",
    value: function addRow(row) {
      this.reallocateColumns();

      for (var fieldName in row) {
        this.columns[fieldName][this.length] = row[fieldName];
      }

      this.length++;
    }
  }, {
    key: "chunkComplete",
    value: function chunkComplete() {
      this.isChunkComplete = true;
    }
  }, {
    key: "isFull",
    value: function isFull() {
      if (this.batchSize === 'auto') {
        return this.isChunkComplete;
      }

      return this.length >= this.allocated;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.pruneColumns();
      var columns = Array.isArray(this.schema) ? this.columns : {};

      if (!Array.isArray(this.schema)) {
        for (var fieldName in this.schema) {
          var field = this.schema[fieldName];
          columns[field.name] = this.columns[field.index];
        }
      }

      this.columns = null;
      this.isChunkComplete = false;
      return {
        data: columns,
        schema: this.schema,
        length: this.length
      };
    }
  }, {
    key: "reallocateColumns",
    value: function reallocateColumns() {
      if (this.length < this.allocated) {
        return;
      }

      this.allocated = this.allocated > 0 ? this.allocated *= 2 : this.batchSize;
      this.columns = [];

      for (var fieldName in this.schema) {
        var field = this.schema[fieldName];
        var ArrayType = field.type || Float32Array;
        var oldColumn = this.columns[field.index];

        if (oldColumn && ArrayBuffer.isView(oldColumn)) {
          var typedArray = new ArrayType(this.allocated);
          typedArray.set(oldColumn);
          this.columns[field.index] = typedArray;
        } else if (oldColumn) {
          oldColumn.length = this.allocated;
          this.columns[field.index] = oldColumn;
        } else {
          this.columns[field.index] = new ArrayType(this.allocated);
        }
      }
    }
  }, {
    key: "pruneColumns",
    value: function pruneColumns() {
      var _this = this;

      this.columns = this.columns.map(function (column) {
        return column.slice(0, _this.length);
      });
    }
  }]);

  return ColumnarTableBatch;
}();

export { ColumnarTableBatch as default };
//# sourceMappingURL=columnar-table-batch.js.map