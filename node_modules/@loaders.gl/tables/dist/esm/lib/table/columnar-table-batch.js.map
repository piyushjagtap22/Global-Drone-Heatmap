{"version":3,"sources":["../../../../src/lib/table/columnar-table-batch.js"],"names":["ColumnarTableBatch","schema","options","batchSize","length","allocated","columns","isChunkComplete","reallocateColumns","row","fieldName","pruneColumns","Array","isArray","field","name","index","data","ArrayType","type","Float32Array","oldColumn","ArrayBuffer","isView","typedArray","set","map","column","slice"],"mappings":"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","sourcesContent":["export default class ColumnarTableBatch {\n  constructor(schema, options = {}) {\n    this.schema = schema;\n    this.batchSize = options.batchSize || 'auto';\n\n    this.length = 0;\n    this.allocated = 0;\n    this.columns = null;\n    this.isChunkComplete = false;\n\n    this.reallocateColumns();\n  }\n\n  addRow(row) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this.reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  // Is this TableBatch full?\n  chunkComplete() {\n    this.isChunkComplete = true;\n  }\n\n  isFull() {\n    if (this.batchSize === 'auto') {\n      return this.isChunkComplete;\n    }\n    return this.length >= this.allocated;\n  }\n\n  getBatch(options = {}) {\n    this.pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = null;\n    this.isChunkComplete = false;\n\n    return {data: columns, schema: this.schema, length: this.length};\n  }\n\n  // HELPERS\n\n  reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : this.batchSize;\n    this.columns = [];\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  pruneColumns() {\n    this.columns = this.columns.map(column => column.slice(0, this.length));\n  }\n}\n"],"file":"columnar-table-batch.js"}