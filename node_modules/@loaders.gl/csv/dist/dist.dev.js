(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../tables/src/index.js":
/*!******************************!*\
  !*** ../tables/src/index.js ***!
  \******************************/
/*! exports provided: Schema, Field, deduceTableSchema, TableBatchBuilder, RowTableBatch, ColumnarTableBatch, JSONLoader, XMLLoader, AsyncQueue, getTypeInfo, DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeMillisecond, TimeSecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_schema_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/schema/schema */ "../tables/src/lib/schema/schema.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Schema", function() { return _lib_schema_schema__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_schema_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/schema/field */ "../tables/src/lib/schema/field.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return _lib_schema_field__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_schema_schema_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/schema/schema-utils */ "../tables/src/lib/schema/schema-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return _lib_schema_schema_utils__WEBPACK_IMPORTED_MODULE_2__["deduceTableSchema"]; });

/* harmony import */ var _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/table/table-batch-builder */ "../tables/src/lib/table/table-batch-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TableBatchBuilder", function() { return _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lib_table_row_table_batch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/table/row-table-batch */ "../tables/src/lib/table/row-table-batch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RowTableBatch", function() { return _lib_table_row_table_batch__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_table_columnar_table_batch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/table/columnar-table-batch */ "../tables/src/lib/table/columnar-table-batch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnarTableBatch", function() { return _lib_table_columnar_table_batch__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _json_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json-loader */ "../tables/src/json-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return _json_loader__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _xml_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./xml-loader */ "../tables/src/xml-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XMLLoader", function() { return _xml_loader__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/utils/async-queue */ "../tables/src/lib/utils/async-queue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncQueue", function() { return _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_types_type_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/types/type-utils */ "../tables/src/lib/types/type-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return _lib_types_type_utils__WEBPACK_IMPORTED_MODULE_9__["getTypeInfo"]; });

/* harmony import */ var _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DataType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Null"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Bool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Int64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Uint64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Float64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Utf8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Date"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DateDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["DateMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Timestamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampMicrosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["TimestampNanosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["Interval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["IntervalDayTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["IntervalYearMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return _lib_types_arrow_like_type__WEBPACK_IMPORTED_MODULE_10__["FixedSizeList"]; });





// TABLE CATEGORY UTILS




// EXPERIMENTAL MICRO-LOADERS



// EXPERIMENTAL APIs


// TYPES





/***/ }),

/***/ "../tables/src/json-loader.js":
/*!************************************!*\
  !*** ../tables/src/json-loader.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TODO - deprecated
function parseTextSync(text, options) {
  return JSON.parse(text);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'JSON',
  extensions: ['json'],
  testText: null,
  parseTextSync
});


/***/ }),

/***/ "../tables/src/lib/schema/field.js":
/*!*****************************************!*\
  !*** ../tables/src/lib/schema/field.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../tables/src/lib/utils/assert.js");
/* harmony import */ var _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");



// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)
// https://loaders.gl/arrowjs/docs/api-reference/field
// A field holds name, nullable, and metadata information about a table "column"
// A Schema is essentially a list of fields

class Field {
  constructor(name, type = null, nullable = false, metadata = new Map()) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof name === 'string');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!type || type instanceof _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_1__["DataType"]);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof nullable === 'boolean');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!metadata || typeof metadata === 'object');

    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  get typeId() {
    return this.type && this.type.typeId;
  }

  clone() {
    return new Field(this.name, this.type, this.nullable, this.metadata);
  }

  compareTo(other) {
    return (
      this.name === other.name &&
      this.type === other.type &&
      this.nullable === other.nullable &&
      this.metadata === other.metadata
    );
  }

  toString() {
    return `${this.type}${this.nullable ? ', nullable' : ''}${
      this.metadata ? `, metadata: ${this.metadata}` : ''
    }`;
  }
}


/***/ }),

/***/ "../tables/src/lib/schema/schema-utils.js":
/*!************************************************!*\
  !*** ../tables/src/lib/schema/schema-utils.js ***!
  \************************************************/
/*! exports provided: deduceTableSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return deduceTableSchema; });
/* harmony import */ var _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/arrow-like/type */ "../tables/src/lib/types/arrow-like/type.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ "../tables/src/lib/schema/schema.js");
/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./field */ "../tables/src/lib/schema/field.js");
// SCHEMA SUPPORT - AUTODEDUCTION




const TYPED_ARRAY_TO_TYPE = {
  Int8Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int8"](),
  Int16Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int16"](),
  Int32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int32"](),
  Uint8Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint8"](),
  Uint8ClampedArray: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint8"](),
  Uint16Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint16"](),
  Uint32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint32"](),
  Float32Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float32"](),
  Float64Array: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float64"]()
};

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TO_TYPE.BigInt64Array = new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Int64"]();
  TYPED_ARRAY_TO_TYPE.BigUint64Array = new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Uint64"]();
}

// Type deduction

/**
 * Type deduction from columnar array
 *
 * Notes:
 * - If the column is a typed array we are able to make a fairly precise type deduction
 * - However we can't tell if it is intervals, dates, fixed size lists etc.
 * - Nullable typed arrays are only supported if backing table is Arrow
 *
 * @param {*} columnArray
 * @returns type, nullable, metadata - (Arrow-like) type information
 */
function getTypeFromColumnArray(columnArray) {
  const ArrayType = columnArray.constructor && columnArray.constructor.name;
  let type = TYPED_ARRAY_TO_TYPE[ArrayType];
  if (type) {
    return {type, nullable: false, metadata: null};
  }

  let metadata = null;
  if (columnArray.length > 0) {
    const value = columnArray[0];
    type = deduceTypeFromValue(value);
    if (type) {
      metadata = new Map([['type', type.toString()]]);
    }
  }

  // We use fields of Arrow-Type Null to indicate that we represent additional, non binary columns
  return {type: new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable: true, metadata};
}

function deduceTableSchema(table, schema = null) {
  const deducedSchema = Array.isArray(table)
    ? deduceSchemaForRowTable(table)
    : deduceSchemaForColumnarTable(table);
  // Deduced schema will fill in missing info from partial options.schema, if provided
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  const fields = [];
  for (const columnName in columnarTable) {
    const columnArray = columnarTable[columnName];
    const {type, nullable, metadata} = getTypeFromColumnArray(columnArray);
    fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](columnName, type, nullable, metadata || new Map()));
  }
  return new _schema__WEBPACK_IMPORTED_MODULE_1__["default"](fields);
}

function deduceSchemaForRowTable(rowTable) {
  const fields = [];
  if (rowTable.length) {
    const row = rowTable[0];
    // Note - handle rows in both array and object format
    if (Array.isArray(row)) {
      // row: [value1, value2, ...]
      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {
        const value = row[columnIndex];
        const name = String(columnIndex);
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](name, new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable, metadata));
      }
    } else {
      for (const columnName in row) {
        // row: {columnName1: value1, columnName2: value2, ...}
        // TODO - Could look at additional rows if nulls in first row
        const value = row[columnName];
        const type = deduceTypeFromValue(value);
        const nullable = true;
        const metadata = new Map([['type', type.toString()]]);
        fields.push(new _field__WEBPACK_IMPORTED_MODULE_2__["default"](columnName, new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"](), nullable, metadata));
      }
    }
  }
  return new _schema__WEBPACK_IMPORTED_MODULE_1__["default"](fields);
}

function deduceTypeFromValue(value) {
  if (value === true || value === false) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Bool"]();
  }
  if (value instanceof Date) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["TimestampMillisecond"]();
  }
  if (value instanceof Number) {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Float32"]();
  }
  if (typeof value === 'string') {
    return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Utf8"]();
  }
  // TODO JS columns (arrays and object valued) are currently null
  return new _types_arrow_like_type__WEBPACK_IMPORTED_MODULE_0__["Null"]();
}


/***/ }),

/***/ "../tables/src/lib/schema/schema.js":
/*!******************************************!*\
  !*** ../tables/src/lib/schema/schema.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Schema; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../tables/src/lib/utils/assert.js");


// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)
// https://loaders.gl/arrowjs/docs/api-reference/schema
class Schema {
  constructor(fields, metadata = null) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.isArray(fields));
    checkNames(fields);
    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  // TODO - arrow only seems to compare fields
  compareTo(other) {
    if (this.fields.metadata !== other.fields.metadata) {
      return false;
    }
    if (this.fields.length !== other.fields.length) {
      return false;
    }
    for (let i = 0; i < this.fields.length; ++i) {
      if (!this.fields[i].compareTo(other.fields[i])) {
        return false;
      }
    }
    return true;
  }

  select(...columnNames) {
    // Ensure column names reference valid fields
    const nameMap = Object.create(null);
    for (const name of columnNames) {
      nameMap[name] = true;
    }
    const selectedFields = columnNames.filter(field => nameMap[field.name]);
    return new Schema(selectedFields, this.metadata);
  }

  selectAt(...columnIndices) {
    // Ensure column indices reference valid fields
    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);
    return new Schema(selectedFields, this.metadata);
  }

  assign(schemaOrFields) {
    let metadata = this.metadata;

    let fields = schemaOrFields;
    if (schemaOrFields instanceof Schema) {
      const otherSchema = schemaOrFields;
      fields = otherSchema.fields;
      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
    }

    // Create a merged list of fields, overwrite fields in place, new fields at end
    const fieldMap = Object.create(null);

    for (const field of this.fields) {
      fieldMap[field.name] = field;
    }

    for (const field of fields) {
      fieldMap[field.name] = field;
    }

    const mergedFields = Object.values(fieldMap);

    return new Schema(mergedFields, metadata);
  }
}

// Warn if any duplicated field names
function checkNames(fields) {
  const usedNames = {};
  for (const field of fields) {
    if (usedNames[field.name]) {
      // eslint-disable-next-line
      console.warn('Schema: duplicated field name', field.name, field);
    }
    usedNames[field.name] = true;
  }
}

function mergeMaps(m1, m2) {
  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}


/***/ }),

/***/ "../tables/src/lib/table/columnar-table-batch.js":
/*!*******************************************************!*\
  !*** ../tables/src/lib/table/columnar-table-batch.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnarTableBatch; });
class ColumnarTableBatch {
  constructor(schema, options = {}) {
    this.schema = schema;
    this.batchSize = options.batchSize || 'auto';

    this.length = 0;
    this.allocated = 0;
    this.columns = null;
    this.isChunkComplete = false;

    this.reallocateColumns();
  }

  addRow(row) {
    // If user keeps pushing rows beyond batch size, reallocate
    this.reallocateColumns();
    for (const fieldName in row) {
      this.columns[fieldName][this.length] = row[fieldName];
    }
    this.length++;
  }

  // Is this TableBatch full?
  chunkComplete() {
    this.isChunkComplete = true;
  }

  isFull() {
    if (this.batchSize === 'auto') {
      return this.isChunkComplete;
    }
    return this.length >= this.allocated;
  }

  getBatch(options = {}) {
    this.pruneColumns();
    const columns = Array.isArray(this.schema) ? this.columns : {};

    // schema is an array if there're no headers
    // object if there are headers
    // columns should match schema format
    if (!Array.isArray(this.schema)) {
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        columns[field.name] = this.columns[field.index];
      }
    }

    this.columns = null;
    this.isChunkComplete = false;

    return {data: columns, schema: this.schema, length: this.length};
  }

  // HELPERS

  reallocateColumns() {
    if (this.length < this.allocated) {
      return;
    }

    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : this.batchSize;
    this.columns = [];

    for (const fieldName in this.schema) {
      const field = this.schema[fieldName];
      const ArrayType = field.type || Float32Array;
      const oldColumn = this.columns[field.index];

      if (oldColumn && ArrayBuffer.isView(oldColumn)) {
        // Copy the old data to the new array
        const typedArray = new ArrayType(this.allocated);
        typedArray.set(oldColumn);
        this.columns[field.index] = typedArray;
      } else if (oldColumn) {
        // Plain array
        oldColumn.length = this.allocated;
        this.columns[field.index] = oldColumn;
      } else {
        // Create new
        this.columns[field.index] = new ArrayType(this.allocated);
      }
    }
  }

  pruneColumns() {
    this.columns = this.columns.map(column => column.slice(0, this.length));
  }
}


/***/ }),

/***/ "../tables/src/lib/table/row-table-batch.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/table/row-table-batch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RowTableBatch; });
const DEFAULT_OPTIONS = {
  batchSize: 'auto',
  convertToObject: true,
  // optimizes memory usage but increases parsing time.
  optimizeMemoryUsage: false
};

class RowTableBatch {
  constructor(schema, options = {}) {
    options = {...DEFAULT_OPTIONS, ...options};

    this.schema = schema;
    this.batchSize = options.batchSize;
    this.convertToObject = options.convertToObject;
    this.optimizeMemoryUsage = options.optimizeMemoryUsage;

    this.rows = null;
    this.length = 0;
    this.isChunkComplete = false;
    this.cursor = 0;

    // schema is an array if there're no headers
    // object if there are headers
    if (!Array.isArray(schema)) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  addRow(row, cursor = null) {
    if (!this.rows) {
      this.rows = new Array(this.batchSize);
      this.length = 0;
    }
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    // We can only convert if we were given a schema
    const convertToObject = this.convertToObject && this.schema;
    this.rows[this.length] = convertToObject ? convertRowToObject(row, this._headers) : row;

    if (this.optimizeMemoryUsage) {
      // A workaround to allocate new strings and don't retain pointers to original strings.
      // https://bugs.chromium.org/p/v8/issues/detail?id=2869
      this.rows[this.length] = JSON.parse(JSON.stringify(this.rows[this.length]));
    }

    this.length++;
  }

  chunkComplete() {
    this.isChunkComplete = true;
  }

  isFull() {
    if (this.batchSize === 'auto') {
      return this.isChunkComplete && this.length > 0;
    }
    return this.rows && this.length >= this.batchSize;
  }

  getBatch() {
    if (this.rows) {
      const rows = this.rows.slice(0, this.length);
      this.rows = null;
      this.isChunkComplete = false;
      return {data: rows, schema: this.schema, length: rows.length, cursor: this.cursor};
    }
    return null;
  }
}

function convertRowToObject(row, headers) {
  if (!row) {
    throw new Error('null row');
  }
  if (!Array.isArray(row)) {
    return row;
  }

  if (!headers) {
    return row;
  }
  const result = {};
  for (let i = 0; i < headers.length; i++) {
    result[headers[i]] = row[i];
  }
  return result;
}


/***/ }),

/***/ "../tables/src/lib/table/table-batch-builder.js":
/*!******************************************************!*\
  !*** ../tables/src/lib/table/table-batch-builder.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TableBatchBuilder; });
const DEFAULT_BATCH_SIZE = 100;

const DEFAULT_OPTIONS = {
  batchSize: DEFAULT_BATCH_SIZE
};

class TableBatchBuilder {
  constructor(TableBatchType, schema, options = {}) {
    this.TableBatchType = TableBatchType;
    this.schema = schema;
    this.options = {...DEFAULT_OPTIONS, ...options};

    this.batch = null;
    this.batchCount = 0;
    this.bytesUsed = 0;
  }

  addRow(row) {
    if (!this.batch) {
      const {TableBatchType} = this;
      this.batch = new TableBatchType(this.schema, this.options);
    }

    this.batch.addRow(row);
  }

  chunkComplete(chunk) {
    this.bytesUsed += chunk.byteLength || chunk.length || 0;
    if (this.batch) {
      this.batch.chunkComplete();
    }
  }

  isFull() {
    return this.batch && this.batch.isFull();
  }

  hasBatch() {
    return Boolean(this.batch);
  }

  getBatch(options = {}) {
    if (Number.isFinite(options.bytesUsed)) {
      this.bytesUsed = options.bytesUsed;
    }

    if (this.batch) {
      const normalizedBatch = this.batch.getBatch();
      this.batch = null;
      normalizedBatch.count = this.batchCount;
      this.batchCount++;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      return normalizedBatch;
    }

    return null;
  }
}


/***/ }),

/***/ "../tables/src/lib/types/arrow-like/enum.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/types/arrow-like/enum.js ***!
  \**************************************************/
/*! exports provided: Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
// This code is adapted from ArrowJS https://github.com/apache/arrow
// under Apache license http://www.apache.org/licenses/LICENSE-2.0

/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow
 * IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */
const Type = {
  /** The default placeholder type */
  NONE: 0,
  /** A NULL type having no physical storage */
  Null: 1,
  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */
  Int: 2,
  /** 2, 4, or 8-byte floating point value */
  Float: 3,
  /** Variable-length bytes (no guarantee of UTF8-ness) */
  Binary: 4,
  /** UTF8 variable-length string as List<Char> */
  Utf8: 5,
  /** Boolean as 1 bit, LSB bit-packed ordering */
  Bool: 6,
  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */
  Decimal: 7,
  /** int32_t days or int64_t milliseconds since the UNIX epoch */
  Date: 8,
  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */
  Time: 9,
  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */
  Timestamp: 10,
  /** YEAR_MONTH or DAY_TIME interval in SQL style */
  Interval: 11,
  /** A list of some logical data type */
  List: 12,
  /** Struct of logical types */
  Struct: 13,
  /** Union of logical types */
  Union: 14,
  /** Fixed-size binary. Each value occupies the same number of bytes */
  FixedSizeBinary: 15,
  /** Fixed-size list. Each value occupies the same number of bytes */
  FixedSizeList: 16,
  /** Map of named logical types */
  Map: 17,

  /** Dictionary aka Category type */
  Dictionary: -1,
  Int8: -2,
  Int16: -3,
  Int32: -4,
  Int64: -5,
  Uint8: -6,
  Uint16: -7,
  Uint32: -8,
  Uint64: -9,
  Float16: -10,
  Float32: -11,
  Float64: -12,
  DateDay: -13,
  DateMillisecond: -14,
  TimestampSecond: -15,
  TimestampMillisecond: -16,
  TimestampMicrosecond: -17,
  TimestampNanosecond: -18,
  TimeSecond: -19,
  TimeMillisecond: -20,
  TimeMicrosecond: -21,
  TimeNanosecond: -22,
  DenseUnion: -23,
  SparseUnion: -24,
  IntervalDayTime: -25,
  IntervalYearMonth: -26
};


/***/ }),

/***/ "../tables/src/lib/types/arrow-like/type.js":
/*!**************************************************!*\
  !*** ../tables/src/lib/types/arrow-like/type.js ***!
  \**************************************************/
/*! exports provided: DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeSecond, TimeMillisecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return DataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return Null; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return Bool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return Int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return Int8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return Int16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return Int32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return Int64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return Uint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return Uint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return Uint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return Uint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return Float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return Float16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return Float32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return Float64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return Utf8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return Date; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return DateDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return DateMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return Time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return TimeSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return TimeMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return Timestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return TimestampSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return TimestampMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return TimestampMicrosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return TimestampNanosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return Interval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return IntervalDayTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return IntervalYearMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return FixedSizeList; });
/* harmony import */ var _enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enum */ "../tables/src/lib/types/arrow-like/enum.js");
// This code is adapted from ArrowJS https://github.com/apache/arrow
// under Apache license http://www.apache.org/licenses/LICENSE-2.0



class DataType {
  static isNull(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Null;
  }
  static isInt(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Int;
  }
  static isFloat(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Float;
  }
  static isBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Binary;
  }
  static isUtf8(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Utf8;
  }
  static isBool(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Bool;
  }
  static isDecimal(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Decimal;
  }
  static isDate(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Date;
  }
  static isTime(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Time;
  }
  static isTimestamp(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Timestamp;
  }
  static isInterval(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Interval;
  }
  static isList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].List;
  }
  static isStruct(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Struct;
  }
  static isUnion(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Union;
  }
  static isFixedSizeBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeBinary;
  }
  static isFixedSizeList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeList;
  }
  static isMap(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Map;
  }
  static isDictionary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Dictionary;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].NONE;
  }
  // get ArrayType() { return Array; }
  compareTo(other) {
    // TODO
    return this === other; // comparer.visit(this, other);
  }
}

// NULL

class Null extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Null;
  }
  get [Symbol.toStringTag]() {
    return 'Null';
  }
  toString() {
    return `Null`;
  }
}

// BOOLEANS

class Bool extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Bool;
  }
  get ArrayType() {
    return Uint8Array;
  }
  get [Symbol.toStringTag]() {
    return 'Bool';
  }
  toString() {
    return `Bool`;
  }
}

// INTS

class Int extends DataType {
  constructor(isSigned, bitWidth) {
    super();
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Int;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? Int32Array : Uint32Array;
      default:
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  }
  get [Symbol.toStringTag]() {
    return 'Int';
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
}

class Int8 extends Int {
  constructor() {
    super(true, 8);
  }
}
class Int16 extends Int {
  constructor() {
    super(true, 16);
  }
}
class Int32 extends Int {
  constructor() {
    super(true, 32);
  }
}
class Int64 extends Int {
  constructor() {
    super(true, 64);
  }
}
class Uint8 extends Int {
  constructor() {
    super(false, 8);
  }
}
class Uint16 extends Int {
  constructor() {
    super(false, 16);
  }
}
class Uint32 extends Int {
  constructor() {
    super(false, 32);
  }
}
class Uint64 extends Int {
  constructor() {
    super(false, 64);
  }
}

// FLOATS

const Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};

class Float extends DataType {
  constructor(precision) {
    super();
    this.precision = precision;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Float;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision.HALF:
        return Uint16Array;
      case Precision.SINGLE:
        return Float32Array;
      case Precision.DOUBLE:
        return Float64Array;
      default:
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  }
  get [Symbol.toStringTag]() {
    return 'Float';
  }
  toString() {
    return `Float${this.precision}`;
  }
}

class Float16 extends Float {
  constructor() {
    super(Precision.HALF);
  }
}
class Float32 extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
}
class Float64 extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
}

// STRINGS

class Utf8 extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Utf8;
  }
  get ArrayType() {
    return Uint8Array;
  }
  get [Symbol.toStringTag]() {
    return 'Utf8';
  }
  toString() {
    return `Utf8`;
  }
}

// DATES, TIMES AND INTERVALS

const DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};

class Date extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Date;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Date';
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
}

class DateDay extends Date {
  constructor() {
    super(DateUnit.DAY);
  }
}
class DateMillisecond extends Date {
  constructor() {
    super(DateUnit.MILLISECOND);
  }
}

const TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};

class Time extends DataType {
  constructor(unit, bitWidth) {
    super();
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Time;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get [Symbol.toStringTag]() {
    return 'Time';
  }
  get ArrayType() {
    return Int32Array;
  }
}

class TimeSecond extends Time {
  constructor() {
    super(TimeUnit.SECOND, 32);
  }
}
class TimeMillisecond extends Time {
  constructor() {
    super(TimeUnit.MILLISECOND, 32);
  }
}
// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }
// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }

class Timestamp extends DataType {
  constructor(unit, timezone = null) {
    super();
    this.unit = unit;
    this.timezone = timezone;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Timestamp;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Timestamp';
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
}

class TimestampSecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.SECOND, timezone);
  }
}
class TimestampMillisecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MILLISECOND, timezone);
  }
}
class TimestampMicrosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MICROSECOND, timezone);
  }
}
class TimestampNanosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.NANOSECOND, timezone);
  }
}

const IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};

class Interval extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].Interval;
  }
  get ArrayType() {
    return Int32Array;
  }
  get [Symbol.toStringTag]() {
    return 'Interval';
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
}

class IntervalDayTime extends Interval {
  constructor() {
    super(IntervalUnit.DAY_TIME);
  }
}
class IntervalYearMonth extends Interval {
  constructor() {
    super(IntervalUnit.YEAR_MONTH);
  }
}

class FixedSizeList extends DataType {
  constructor(listSize, child) {
    super();
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_0__["Type"].FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  get [Symbol.toStringTag]() {
    return 'FixedSizeList';
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
}


/***/ }),

/***/ "../tables/src/lib/types/type-utils.js":
/*!*********************************************!*\
  !*** ../tables/src/lib/types/type-utils.js ***!
  \*********************************************/
/*! exports provided: getTypeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return getTypeInfo; });
/* harmony import */ var _arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrow-like/enum */ "../tables/src/lib/types/arrow-like/enum.js");


function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}

let ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};
    for (const key in _arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__["Type"]) {
      ReverseType[_arrow_like_enum__WEBPACK_IMPORTED_MODULE_0__["Type"][key]] = key;
    }
  }

  return ReverseType[typeKey];
}


/***/ }),

/***/ "../tables/src/lib/utils/assert.js":
/*!*****************************************!*\
  !*** ../tables/src/lib/utils/assert.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../tables/src/lib/utils/async-queue.js":
/*!**********************************************!*\
  !*** ../tables/src/lib/utils/async-queue.js ***!
  \**********************************************/
/*! exports provided: takeAsync, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeAsync", function() { return takeAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncQueue; });
// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license
// http://2ality.com/2016/10/asynchronous-iteration.html

class ArrayQueue extends Array {
  enqueue(value) {
    // Add at the end
    return this.push(value);
  }
  dequeue() {
    // Remove first element
    return this.shift();
  }
}

/**
 * @returns a Promise for an Array with the elements
 * in `asyncIterable`
 */
async function takeAsync(asyncIterable, count = Infinity) {
  const result = [];
  const iterator = asyncIterable[Symbol.asyncIterator]();
  while (result.length < count) {
    const {value, done} = await iterator.next();
    if (done) {
      break;
    }
    result.push(value);
  }
  return result;
}

class AsyncQueue {
  constructor() {
    // enqueues > dequeues
    this._values = new ArrayQueue();
    // dequeues > enqueues
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  close() {
    while (this._settlers.length > 0) {
      this._settlers.dequeue().resolve({done: true});
    }
    this._closed = true;
  }

  [Symbol.asyncIterator]() {
    return this;
  }

  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }

    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }
      const settler = this._settlers.dequeue();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({value});
      }
    } else {
      this._values.enqueue(value);
    }
  }

  /**
   * @returns a Promise for an IteratorResult
   */
  next() {
    if (this._values.length > 0) {
      const value = this._values.dequeue();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({value});
    }

    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }
      return Promise.resolve({done: true});
    }
    // Wait for new values to be enqueued
    return new Promise((resolve, reject) => {
      this._settlers.enqueue({resolve, reject});
    });
  }
}


/***/ }),

/***/ "../tables/src/lib/xml/parse-xml.js":
/*!******************************************!*\
  !*** ../tables/src/lib/xml/parse-xml.js ***!
  \******************************************/
/*! exports provided: default, parseXMLSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseXML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseXMLSupported", function() { return parseXMLSupported; });
/* global window, DOMParser */
function parseXML(xml) {
  if (window.DOMParser) {
    const xmlDoc = new window.DOMParser().parseFromString(xml, 'application/xml');
    const parseError = isXMLParseError(xmlDoc);
    if (parseError) {
      throw new Error(parseError);
    }
    return xmlDoc;
  }

  if (typeof window.ActiveXObject !== 'undefined') {
    const xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
    if (xmlDoc) {
      xmlDoc.async = 'false';
      xmlDoc.loadXML(xml);
      return xmlDoc;
    }
  }

  throw new Error('No XML parser available');
}

function parseXMLSupported() {
  if (typeof window === 'undefined') {
    return false;
  }

  if (window.DOMParser) {
    return true;
  }

  if (typeof window.ActiveXObject !== 'undefined' && new window.ActiveXObject('Microsoft.XMLDOM')) {
    return true;
  }

  return false;
}

// https://stackoverflow.com/questions/11563554/how-do-i-detect-xml-parsing-errors-when-using-javascripts-domparser-in-a-cross
function isXMLParseError(parsedDocument) {
  const parser = new DOMParser();
  const erroneousParse = parser.parseFromString('<', 'text/xml');
  const parsererrorNS = erroneousParse.getElementsByTagName('parsererror')[0].namespaceURI;

  if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {
    // In PhantomJS the parseerror element doesn't seem to have a special namespace,
    // so we are just guessing here :(
    const errorElements = parsedDocument.getElementsByTagName('parsererror');
    return errorElements.length ? errorElements[0].innerHTML : null;
  }

  return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;
}


/***/ }),

/***/ "../tables/src/xml-loader.js":
/*!***********************************!*\
  !*** ../tables/src/xml-loader.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/xml/parse-xml */ "../tables/src/lib/xml/parse-xml.js");


const XML_HEADER = '<?xml';

function testText(text) {
  return text.startsWith(XML_HEADER);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'KML',
  extensions: ['kml'],
  supported: Object(_lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__["parseXMLSupported"])(),
  testText,
  parseTextSync: _lib_xml_parse_xml__WEBPACK_IMPORTED_MODULE_0__["default"],
  browserOnly: true,
  worker: false
});


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");
const _global = typeof window === 'undefined' ? global : window;
// @ts-ignore
_global.loaders = _global.loaders || {};
// @ts-ignore
module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/csv-loader.js":
/*!***************************!*\
  !*** ./src/csv-loader.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/tables */ "../tables/src/index.js");
/* harmony import */ var _libs_papaparse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/papaparse */ "./src/libs/papaparse.js");
/* harmony import */ var _libs_papaparse__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_papaparse__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_async_iterator_streamer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/async-iterator-streamer */ "./src/lib/async-iterator-streamer.js");
/* global TextDecoder */



/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.13" : undefined;

const CSVLoaderOptions = {
  csv: {
    TableBatch: _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__["RowTableBatch"],
    batchSize: 10,
    optimizeMemoryUsage: false,
    // CSV options
    header: 'auto',
    rowFormat: 'auto',
    columnPrefix: 'column',
    // delimiter: auto
    // newline: auto
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: false,
    // transform: null?
    delimitersToGuess: [',', '\t', '|', ';']
    // fastMode: auto
  }
};

/** @type {LoaderObject} */
/* harmony default export */ __webpack_exports__["default"] = ({
  id: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),
  parseText: parseCSV,
  parseInBatches: parseCSVInBatches,
  testText: null,
  options: CSVLoaderOptions
});

async function parseCSV(csvText, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...CSVLoaderOptions, ...options};
  options.csv = {...CSVLoaderOptions.csv, ...options.csv};

  const header = await hasHeader(csvText, options);

  const config = {
    dynamicTyping: true, // Convert numbers and boolean values in rows from strings
    ...options.csv,
    header,
    download: false, // We handle loading, no need for papaparse to do it for us
    error: e => {
      throw new Error(e);
    }
  };

  const result = _libs_papaparse__WEBPACK_IMPORTED_MODULE_1___default.a.parse(csvText, config);
  return result.data;
}

// TODO - support batch size 0 = no batching/single batch?
function parseCSVInBatches(asyncIterator, options) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...CSVLoaderOptions, ...options};
  options.csv = {...CSVLoaderOptions.csv, ...options.csv};

  const {batchSize, optimizeMemoryUsage} = options.csv;
  const TableBatchType = options.csv.TableBatch;

  const asyncQueue = new _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__["AsyncQueue"]();

  const convertToObject = options.csv.rowFormat === 'object';

  let isFirstRow = true;
  let headerRow = null;
  let tableBatchBuilder = null;
  let schema = null;

  const config = {
    dynamicTyping: true, // Convert numbers and boolean values in rows from strings,
    ...options.csv,
    header: false, // Unfortunately, header detection is not automatic and does not infer types
    download: false, // We handle loading, no need for papaparse to do it for us
    // chunk(results, parser) {
    //   // TODO batch before adding to queue.
    //   console.log('Chunk:', results, parser);
    //   asyncQueue.enqueue(results.data);
    // },

    // step is called on every row
    step(results, parser) {
      const row = results.data;
      const bytesUsed = results.meta.cursor;

      // Check if we need to save a header row
      if (isFirstRow && !headerRow) {
        // Auto detects or can be forced with options.csv.header
        const header = isHeaderRow(row, options);
        if (header) {
          headerRow = row;
          return;
        }
      }

      // If first data row, we can deduce the schema
      if (isFirstRow) {
        isFirstRow = false;
        if (!headerRow) {
          headerRow = [];
          for (let i = 0; i < row.length; i++) {
            headerRow[i] = `${options.csv.columnPrefix}${i + 1}`;
          }
        }
        schema = deduceSchema(row, headerRow);
      }

      // Add the row
      tableBatchBuilder =
        tableBatchBuilder ||
        new _loaders_gl_tables__WEBPACK_IMPORTED_MODULE_0__["TableBatchBuilder"](TableBatchType, schema, {
          batchSize,
          convertToObject,
          optimizeMemoryUsage
        });

      tableBatchBuilder.addRow(row);
      // If a batch has been completed, emit it
      if (tableBatchBuilder.isFull()) {
        asyncQueue.enqueue(tableBatchBuilder.getBatch({bytesUsed}));
      }
    },

    // complete is called when all rows have been read
    complete(results, file) {
      const bytesUsed = results.meta.cursor;
      // Ensure any final (partial) batch gets emitted
      const batch = tableBatchBuilder.getBatch({bytesUsed});
      if (batch) {
        asyncQueue.enqueue(batch);
      }
      asyncQueue.close();
    }
  };

  _libs_papaparse__WEBPACK_IMPORTED_MODULE_1___default.a.parse(asyncIterator, config, _lib_async_iterator_streamer__WEBPACK_IMPORTED_MODULE_2__["default"]);

  // TODO - Does it matter if we return asyncIterable or asyncIterator
  // return asyncQueue[Symbol.asyncIterator]();
  return asyncQueue;
}

function isHeaderRow(row, options) {
  if (options && options.csv.header !== 'auto') {
    return Boolean(options.csv.header);
  }

  return row.every(value => typeof value === 'string');
}

async function hasHeader(csvText, options) {
  if (options.csv.header !== 'auto') {
    return Boolean(options.csv.header);
  }

  return await new Promise((resolve, reject) => {
    _libs_papaparse__WEBPACK_IMPORTED_MODULE_1___default.a.parse(csvText, {
      download: false,
      dynamicTyping: true,
      step: (results, parser) => {
        parser.abort();
        const row = results.data;
        // Test the row
        resolve(isHeaderRow(row));
      },
      error: e => {
        reject(new Error(e));
      }
    });
  });
}

function deduceSchema(row, headerRow) {
  const schema = headerRow ? {} : [];
  for (let i = 0; i < row.length; i++) {
    const columnName = (headerRow && headerRow[i]) || i;
    const value = row[i];
    switch (typeof value) {
      case 'number':
      case 'boolean':
        // TODO - booleans could be handled differently...
        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};
        break;
      case 'string':
      default:
        schema[columnName] = {name: String(columnName), index: i, type: Array};
      // We currently only handle numeric rows
      // TODO we could offer a function to map strings to numbers?
    }
  }
  return schema;
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: CSVLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _csv_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./csv-loader */ "./src/csv-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSVLoader", function() { return _csv_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./src/lib/async-iterator-streamer.js":
/*!********************************************!*\
  !*** ./src/lib/async-iterator-streamer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncIteratorStreamer; });
/* harmony import */ var _libs_papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/papaparse */ "./src/libs/papaparse.js");
/* harmony import */ var _libs_papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_papaparse__WEBPACK_IMPORTED_MODULE_0__);
// A custom papaparse `Streamer` for async iterators
// Ideally this can be contributed back to papaparse
// Or papaparse can expose Streamer API so we can extend without forking.

// @ts-nocheck
/* eslint-disable no-invalid-this */
/* global TextDecoder */

// Note: papaparse is not an ES6 module

const {ChunkStreamer} = _libs_papaparse__WEBPACK_IMPORTED_MODULE_0___default.a;

function AsyncIteratorStreamer(config) {
  config = config || {};

  ChunkStreamer.call(this, config);

  this.textDecoder = new TextDecoder(this._config.encoding);

  // Implement ChunkStreamer base class methods

  // this.pause = function() {
  //   ChunkStreamer.prototype.pause.apply(this, arguments);
  // };

  // this.resume = function() {
  //   ChunkStreamer.prototype.resume.apply(this, arguments);
  //   this._input.resume();
  // };

  this.stream = async function(asyncIterator) {
    this._input = asyncIterator;

    try {
      // ES2018 version
      // TODO - check for pause and abort flags?
      for await (const chunk of asyncIterator) {
        this.parseChunk(this.getStringChunk(chunk));
      }

      // ES5 VERSION
      // while (true) {
      //   asyncIterator.next().then(function(value) {
      //     if (value.done) {
      //       // finalize iterator?
      //     }
      //   }
      //   const  = await ;
      //   if (done) return total;
      //   total += value.length;
      // }

      this._finished = true;
      this.parseChunk('');
    } catch (error) {
      // Inform ChunkStreamer base class of error
      this._sendError(error);
    }
  };

  this._nextChunk = function nextChunk() {
    // Left empty, as async iterator automatically pulls next chunk
  };

  // HELPER METHODS
  this.getStringChunk = function(chunk) {
    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});
  };
}

AsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);
AsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;


/***/ }),

/***/ "./src/libs/papaparse.js":
/*!*******************************!*\
  !*** ./src/libs/papaparse.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

// This is a fork of papaparse
// https://github.com/mholt/PapaParse
/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
// FORK SUMMARY:
// - Adopt ES6 exports
// - Implement new AsyncIteratorStreamer
// - Remove non Async Iterator streamers (can all be handled by new streamer)
// - Remove unused Worker support (loaders.gl worker system used instead)
// - Remove unused jQuery plugin support

/* eslint-disable */
// @ts-nocheck
var global = (function() {
  // alternative method, similar to `Function('return this')()`
  // but without using `eval` (which is disabled when
  // using Content Security Policy).

  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }

  // When running tests none of the above have been defined
  return {};
})();

var IS_PAPA_WORKER = false;

var Papa = {};
module.exports = Papa;
Papa.parse = CsvToJson;
Papa.unparse = JsonToCsv;

Papa.RECORD_SEP = String.fromCharCode(30);
Papa.UNIT_SEP = String.fromCharCode(31);
Papa.BYTE_ORDER_MARK = '\ufeff';
Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
Papa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;
Papa.NODE_STREAM_INPUT = 1;

// Configurable chunk sizes for local and remote files, respectively
Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
Papa.DefaultDelimiter = ','; // Used if not specified and detection fails

// Exposed for testing and development only
Papa.Parser = Parser;
Papa.ParserHandle = ParserHandle;

// BEGIN FORK
Papa.ChunkStreamer = ChunkStreamer;
Papa.StringStreamer = StringStreamer;
/*
Papa.NetworkStreamer = NetworkStreamer;
Papa.FileStreamer = FileStreamer;
Papa.ReadableStreamStreamer = ReadableStreamStreamer;
if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
  Papa.DuplexStreamStreamer = DuplexStreamStreamer;
}
*/
// END FORK

// BEGIN FORK
// Adds an argument to papa.parse
// function CsvToJson(_input, _config)
function CsvToJson(
  _input,
  _config,
  UserDefinedStreamer // BEGIN FORK
) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;
  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    // Will be filled on first row call
    dynamicTyping = {};
  }
  _config.dynamicTyping = dynamicTyping;

  _config.transform = isFunction(_config.transform) ? _config.transform : false;

  if (_config.worker && Papa.WORKERS_SUPPORTED) {
    var w = newWorker();

    w.userStep = _config.step;
    w.userChunk = _config.chunk;
    w.userComplete = _config.complete;
    w.userError = _config.error;

    _config.step = isFunction(_config.step);
    _config.chunk = isFunction(_config.chunk);
    _config.complete = isFunction(_config.complete);
    _config.error = isFunction(_config.error);
    delete _config.worker; // prevent infinite loop

    w.postMessage({
      input: _input,
      config: _config,
      workerId: w.id
    });

    return;
  }

  var streamer = null;
  /*
  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    // create a node Duplex stream for use
    // with .pipe
    streamer = new DuplexStreamStreamer(_config);
    return streamer.getStream();
  } else
  */
  if (typeof _input === 'string') {
    // if (_config.download) streamer = new NetworkStreamer(_config);
    // else
    streamer = new StringStreamer(_config);
  }
  /*
  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {
    streamer = new ReadableStreamStreamer(_config);
  } else if ((global.File && _input instanceof File) || _input instanceof Object)
    // ...Safari. (see issue #106)
    streamer = new FileStreamer(_config);
  */

  // BEGIN FORK
  if (!streamer) {
    streamer = new UserDefinedStreamer(_config);
  }
  // END FORK

  return streamer.stream(_input);
}

function JsonToCsv(_input, _config) {
  // Default configuration

  /** whether to surround every datum with quotes */
  var _quotes = false;

  /** whether to write headers */
  var _writeHeader = true;

  /** delimiting character(s) */
  var _delimiter = ',';

  /** newline character(s) */
  var _newline = '\r\n';

  /** quote character */
  var _quoteChar = '"';

  /** escaped quote character, either "" or <config.escapeChar>" */
  var _escapedQuote = _quoteChar + _quoteChar;

  /** whether to skip empty lines */
  var _skipEmptyLines = false;

  /** the columns (keys) we expect when we unparse objects */
  var _columns = null;

  unpackConfig();

  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

  if (typeof _input === 'string') _input = JSON.parse(_input);

  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);
    else if (typeof _input[0] === 'object')
      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
  } else if (typeof _input === 'object') {
    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);

    if (Array.isArray(_input.data)) {
      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;

      if (!_input.fields)
        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);

      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')
        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']
    }

    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }

  // Default (any valid paths should return before this)
  throw new Error('Unable to serialize unrecognized input');

  function unpackConfig() {
    if (typeof _config !== 'object') return;

    if (
      typeof _config.delimiter === 'string' &&
      !Papa.BAD_DELIMITERS.filter(function(value) {
        return _config.delimiter.indexOf(value) !== -1;
      }).length
    ) {
      _delimiter = _config.delimiter;
    }

    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))
      _quotes = _config.quotes;

    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')
      _skipEmptyLines = _config.skipEmptyLines;

    if (typeof _config.newline === 'string') _newline = _config.newline;

    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;

    if (typeof _config.header === 'boolean') _writeHeader = _config.header;

    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0) throw new Error('Option columns is empty');

      _columns = _config.columns;
    }

    if (_config.escapeChar !== undefined) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }

  /** Turns an object's keys into an array */
  function objectKeys(obj) {
    if (typeof obj !== 'object') return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }

  /** The double for loop that iterates the data and writes out a CSV string including header row */
  function serialize(fields, data, skipEmptyLines) {
    var csv = '';

    if (typeof fields === 'string') fields = JSON.parse(fields);
    if (typeof data === 'string') data = JSON.parse(data);

    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);

    // If there a header row, write it first
    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0) csv += _delimiter;
        csv += safe(fields[i], i);
      }
      if (data.length > 0) csv += _newline;
    }

    // Then write out the data
    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;

      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
      if (skipEmptyLines && !hasHeader) {
        emptyLine =
          skipEmptyLines === 'greedy'
            ? data[row].join('').trim() === ''
            : data[row].length === 1 && data[row][0].length === 0;
      }
      if (skipEmptyLines === 'greedy' && hasHeader) {
        var line = [];
        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }
        emptyLine = line.join('').trim() === '';
      }
      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine) csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }
        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {
          csv += _newline;
        }
      }
    }
    return csv;
  }

  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
  function safe(str, col) {
    if (typeof str === 'undefined' || str === null) return '';

    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);

    str = str.toString().replace(quoteCharRegex, _escapedQuote);

    var needsQuotes =
      (typeof _quotes === 'boolean' && _quotes) ||
      (Array.isArray(_quotes) && _quotes[col]) ||
      hasAny(str, Papa.BAD_DELIMITERS) ||
      str.indexOf(_delimiter) > -1 ||
      str.charAt(0) === ' ' ||
      str.charAt(str.length - 1) === ' ';

    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }

  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;
    return false;
  }
}

/** ChunkStreamer is the base prototype for various streamer implementations. */
function ChunkStreamer(config) {
  this._handle = null;
  this._finished = false;
  this._completed = false;
  this._input = null;
  this._baseIndex = 0;
  this._partialLine = '';
  this._rowCount = 0;
  this._start = 0;
  this._nextChunk = null;
  this.isFirstChunk = true;
  this._completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  replaceConfig.call(this, config);

  this.parseChunk = function(chunk, isFakeChunk) {
    // First chunk pre-processing
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);
      if (modifiedChunk !== undefined) chunk = modifiedChunk;
    }
    this.isFirstChunk = false;

    // Rejoin the line we likely just split in two by chunking the file
    var aggregate = this._partialLine + chunk;
    this._partialLine = '';

    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

    if (this._handle.paused() || this._handle.aborted()) return;

    var lastIndex = results.meta.cursor;

    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }

    if (results && results.data) this._rowCount += results.data.length;

    var finishedIncludingPreview =
      this._finished || (this._config.preview && this._rowCount >= this._config.preview);

    if (IS_PAPA_WORKER) {
      global.postMessage({
        results: results,
        workerId: Papa.WORKER_ID,
        finished: finishedIncludingPreview
      });
    } else if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);
      if (this._handle.paused() || this._handle.aborted()) return;
      results = undefined;
      this._completeResults = undefined;
    }

    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }

    if (
      !this._completed &&
      finishedIncludingPreview &&
      isFunction(this._config.complete) &&
      (!results || !results.meta.aborted)
    ) {
      this._config.complete(this._completeResults, this._input);
      this._completed = true;
    }

    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();

    return results;
  };

  this._sendError = function(error) {
    if (isFunction(this._config.error)) this._config.error(error);
    else if (IS_PAPA_WORKER && this._config.error) {
      global.postMessage({
        workerId: Papa.WORKER_ID,
        error: error,
        finished: false
      });
    }
  };

  function replaceConfig(config) {
    // Deep-copy the config so we can edit it
    var configCopy = copy(config);
    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!
    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy; // persist the copy to the caller
  }
}

/*
function NetworkStreamer(config) {
  config = config || {};
  if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;
  ChunkStreamer.call(this, config);

  var xhr;

  if (IS_WORKER) {
    this._nextChunk = function() {
      this._readChunk();
      this._chunkLoaded();
    };
  } else {
    this._nextChunk = function() {
      this._readChunk();
    };
  }

  this.stream = function(url) {
    this._input = url;
    this._nextChunk(); // Starts streaming
  };

  this._readChunk = function() {
    if (this._finished) {
      this._chunkLoaded();
      return;
    }

    xhr = new XMLHttpRequest();

    if (this._config.withCredentials) {
      xhr.withCredentials = this._config.withCredentials;
    }

    if (!IS_WORKER) {
      xhr.onload = bindFunction(this._chunkLoaded, this);
      xhr.onerror = bindFunction(this._chunkError, this);
    }

    xhr.open('GET', this._input, !IS_WORKER);
    // Headers can only be set when once the request state is OPENED
    if (this._config.downloadRequestHeaders) {
      var headers = this._config.downloadRequestHeaders;

      for (var headerName in headers) {
        xhr.setRequestHeader(headerName, headers[headerName]);
      }
    }

    if (this._config.chunkSize) {
      var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive
      xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);
    }

    try {
      xhr.send();
    } catch (err) {
      this._chunkError(err.message);
    }

    if (IS_WORKER && xhr.status === 0) this._chunkError();
    else this._start += this._config.chunkSize;
  };

  this._chunkLoaded = function() {
    if (xhr.readyState !== 4) return;

    if (xhr.status < 200 || xhr.status >= 400) {
      this._chunkError();
      return;
    }

    this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
    this.parseChunk(xhr.responseText);
  };

  this._chunkError = function(errorMessage) {
    var errorText = xhr.statusText || errorMessage;
    this._sendError(new Error(errorText));
  };

  function getFileSize(xhr) {
    var contentRange = xhr.getResponseHeader('Content-Range');
    if (contentRange === null) {
      // no content range, then finish!
      return -1;
    }
    return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
  }
}
NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
NetworkStreamer.prototype.constructor = NetworkStreamer;

function FileStreamer(config) {
  config = config || {};
  if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;
  ChunkStreamer.call(this, config);

  var reader, slice;

  // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
  // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
  var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105

  this.stream = function(file) {
    this._input = file;
    slice = file.slice || file.webkitSlice || file.mozSlice;

    if (usingAsyncReader) {
      reader = new FileReader(); // Preferred method of reading files, even in workers
      reader.onload = bindFunction(this._chunkLoaded, this);
      reader.onerror = bindFunction(this._chunkError, this);
    } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox

    this._nextChunk(); // Starts streaming
  };

  this._nextChunk = function() {
    if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
      this._readChunk();
  };

  this._readChunk = function() {
    var input = this._input;
    if (this._config.chunkSize) {
      var end = Math.min(this._start + this._config.chunkSize, this._input.size);
      input = slice.call(input, this._start, end);
    }
    var txt = reader.readAsText(input, this._config.encoding);
    if (!usingAsyncReader) this._chunkLoaded({target: {result: txt}}); // mimic the async signature
  };

  this._chunkLoaded = function(event) {
    // Very important to increment start each time before handling results
    this._start += this._config.chunkSize;
    this._finished = !this._config.chunkSize || this._start >= this._input.size;
    this.parseChunk(event.target.result);
  };

  this._chunkError = function() {
    this._sendError(reader.error);
  };
}
FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
FileStreamer.prototype.constructor = FileStreamer;
*/

function StringStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);

  var remaining;
  this.stream = function(s) {
    remaining = s;
    return this._nextChunk();
  };
  this._nextChunk = function() {
    if (this._finished) return;
    var size = this._config.chunkSize;
    var chunk = size ? remaining.substr(0, size) : remaining;
    remaining = size ? remaining.substr(size) : '';
    this._finished = !remaining;
    return this.parseChunk(chunk);
  };
}
StringStreamer.prototype = Object.create(StringStreamer.prototype);
StringStreamer.prototype.constructor = StringStreamer;

/*
function ReadableStreamStreamer(config) {
  config = config || {};

  ChunkStreamer.call(this, config);

  var queue = [];
  var parseOnData = true;
  var streamHasEnded = false;

  this.pause = function() {
    ChunkStreamer.prototype.pause.apply(this, arguments);
    this._input.pause();
  };

  this.resume = function() {
    ChunkStreamer.prototype.resume.apply(this, arguments);
    this._input.resume();
  };

  this.stream = function(stream) {
    this._input = stream;

    this._input.on('data', this._streamData);
    this._input.on('end', this._streamEnd);
    this._input.on('error', this._streamError);
  };

  this._checkIsFinished = function() {
    if (streamHasEnded && queue.length === 1) {
      this._finished = true;
    }
  };

  this._nextChunk = function() {
    this._checkIsFinished();
    if (queue.length) {
      this.parseChunk(queue.shift());
    } else {
      parseOnData = true;
    }
  };

  this._streamData = bindFunction(function(chunk) {
    try {
      queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));

      if (parseOnData) {
        parseOnData = false;
        this._checkIsFinished();
        this.parseChunk(queue.shift());
      }
    } catch (error) {
      this._streamError(error);
    }
  }, this);

  this._streamError = bindFunction(function(error) {
    this._streamCleanUp();
    this._sendError(error);
  }, this);

  this._streamEnd = bindFunction(function() {
    this._streamCleanUp();
    streamHasEnded = true;
    this._streamData('');
  }, this);

  this._streamCleanUp = bindFunction(function() {
    this._input.removeListener('data', this._streamData);
    this._input.removeListener('end', this._streamEnd);
    this._input.removeListener('error', this._streamError);
  }, this);
}
ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;

function DuplexStreamStreamer(_config) {
  var Duplex = require('stream').Duplex;
  var config = copy(_config);
  var parseOnWrite = true;
  var writeStreamHasFinished = false;
  var parseCallbackQueue = [];
  var stream = null;

  this._onCsvData = function(results) {
    var data = results.data;
    if (!stream.push(data) && !this._handle.paused()) {
      // the writeable consumer buffer has filled up
      // so we need to pause until more items
      // can be processed
      this._handle.pause();
    }
  };

  this._onCsvComplete = function() {
    // node will finish the read stream when
    // null is pushed
    stream.push(null);
  };

  config.step = bindFunction(this._onCsvData, this);
  config.complete = bindFunction(this._onCsvComplete, this);
  ChunkStreamer.call(this, config);

  this._nextChunk = function() {
    if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
      this._finished = true;
    }
    if (parseCallbackQueue.length) {
      parseCallbackQueue.shift()();
    } else {
      parseOnWrite = true;
    }
  };

  this._addToParseQueue = function(chunk, callback) {
    // add to queue so that we can indicate
    // completion via callback
    // node will automatically pause the incoming stream
    // when too many items have been added without their
    // callback being invoked
    parseCallbackQueue.push(
      bindFunction(function() {
        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));
        if (isFunction(callback)) {
          return callback();
        }
      }, this)
    );
    if (parseOnWrite) {
      parseOnWrite = false;
      this._nextChunk();
    }
  };

  this._onRead = function() {
    if (this._handle.paused()) {
      // the writeable consumer can handle more data
      // so resume the chunk parsing
      this._handle.resume();
    }
  };

  this._onWrite = function(chunk, encoding, callback) {
    this._addToParseQueue(chunk, callback);
  };

  this._onWriteComplete = function() {
    writeStreamHasFinished = true;
    // have to write empty string
    // so parser knows its done
    this._addToParseQueue('');
  };

  this.getStream = function() {
    return stream;
  };
  stream = new Duplex({
    readableObjectMode: true,
    decodeStrings: false,
    read: bindFunction(this._onRead, this),
    write: bindFunction(this._onWrite, this)
  });
  stream.once('finish', bindFunction(this._onWriteComplete, this));
}
if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
  DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
  DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
}
*/

// Use one ParserHandle per entire CSV file or string
function ParserHandle(_config) {
  // One goal is to minimize the use of regular expressions...
  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;

  var self = this;
  var _stepCounter = 0; // Number of times step was called (number of rows parsed)
  var _rowCounter = 0; // Number of rows that have been parsed so far
  var _input; // The input being parsed
  var _parser; // The core parser being used
  var _paused = false; // Whether we are paused or not
  var _aborted = false; // Whether the parser has aborted or not
  var _delimiterError; // Temporary state between delimiter detection and processing results
  var _fields = []; // Fields are from the header row of the input, if there is one
  var _results = {
    // The last results returned from the parser
    data: [],
    errors: [],
    meta: {}
  };

  if (isFunction(_config.step)) {
    var userStep = _config.step;
    _config.step = function(results) {
      _results = results;

      if (needsHeaderRow()) processResults();
      // only call user's step function after header row
      else {
        processResults();

        // It's possbile that this line was empty and there's no row here after all
        if (_results.data.length === 0) return;

        _stepCounter += results.data.length;
        if (_config.preview && _stepCounter > _config.preview) _parser.abort();
        else userStep(_results, self);
      }
    };
  }

  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  this.parse = function(input, baseIndex, ignoreLastRow) {
    var quoteChar = _config.quoteChar || '"';
    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);

    _delimiterError = false;
    if (!_config.delimiter) {
      var delimGuess = guessDelimiter(
        input,
        _config.newline,
        _config.skipEmptyLines,
        _config.comments,
        _config.delimitersToGuess
      );
      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;
      else {
        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
        _config.delimiter = Papa.DefaultDelimiter;
      }
      _results.meta.delimiter = _config.delimiter;
    } else if (isFunction(_config.delimiter)) {
      _config.delimiter = _config.delimiter(input);
      _results.meta.delimiter = _config.delimiter;
    }

    var parserConfig = copy(_config);
    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row

    _input = input;
    _parser = new Parser(parserConfig);
    _results = _parser.parse(_input, baseIndex, ignoreLastRow);
    processResults();
    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};
  };

  this.paused = function() {
    return _paused;
  };

  this.pause = function() {
    _paused = true;
    _parser.abort();
    _input = _input.substr(_parser.getCharIndex());
  };

  this.resume = function() {
    _paused = false;
    self.streamer.parseChunk(_input, true);
  };

  this.aborted = function() {
    return _aborted;
  };

  this.abort = function() {
    _aborted = true;
    _parser.abort();
    _results.meta.aborted = true;
    if (isFunction(_config.complete)) _config.complete(_results);
    _input = '';
  };

  function testEmptyLine(s) {
    return _config.skipEmptyLines === 'greedy'
      ? s.join('').trim() === ''
      : s.length === 1 && s[0].length === 0;
  }

  function processResults() {
    if (_results && _delimiterError) {
      addError(
        'Delimiter',
        'UndetectableDelimiter',
        "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'"
      );
      _delimiterError = false;
    }

    if (_config.skipEmptyLines) {
      for (var i = 0; i < _results.data.length; i++)
        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);
    }

    if (needsHeaderRow()) fillHeaderFields();

    return applyHeaderAndDynamicTypingAndTransformation();
  }

  function needsHeaderRow() {
    return _config.header && _fields.length === 0;
  }

  function fillHeaderFields() {
    if (!_results) return;

    function addHeder(header) {
      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);

      _fields.push(header);
    }

    if (Array.isArray(_results.data[0])) {
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
        _results.data[i].forEach(addHeder);

      _results.data.splice(0, 1);
    }
    // if _results.data[0] is not an array, we are in a step where _results.data is the row.
    else _results.data.forEach(addHeder);
  }

  function shouldApplyDynamicTyping(field) {
    // Cache function values to avoid calling it for each row
    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
    }
    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
  }

  function parseDynamic(field, value) {
    if (shouldApplyDynamicTyping(field)) {
      if (value === 'true' || value === 'TRUE') return true;
      else if (value === 'false' || value === 'FALSE') return false;
      else if (FLOAT.test(value)) return parseFloat(value);
      else if (ISO_DATE.test(value)) return new Date(value);
      else return value === '' ? null : value;
    }
    return value;
  }

  function applyHeaderAndDynamicTypingAndTransformation() {
    if (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))
      return _results;

    function processRow(rowSource, i) {
      var row = _config.header ? {} : [];

      var j;
      for (j = 0; j < rowSource.length; j++) {
        var field = j;
        var value = rowSource[j];

        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];

        if (_config.transform) value = _config.transform(value, field);

        value = parseDynamic(field, value);

        if (field === '__parsed_extra') {
          row[field] = row[field] || [];
          row[field].push(value);
        } else row[field] = value;
      }

      if (_config.header) {
        if (j > _fields.length)
          addError(
            'FieldMismatch',
            'TooManyFields',
            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
        else if (j < _fields.length)
          addError(
            'FieldMismatch',
            'TooFewFields',
            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
      }

      return row;
    }

    var incrementBy = 1;
    if (!_results.data[0] || Array.isArray(_results.data[0])) {
      _results.data = _results.data.map(processRow);
      incrementBy = _results.data.length;
    } else _results.data = processRow(_results.data, 0);

    if (_config.header && _results.meta) _results.meta.fields = _fields;

    _rowCounter += incrementBy;
    return _results;
  }

  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;

    delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0,
        avgFieldCount = 0,
        emptyLinesCount = 0;
      fieldCountPrevRow = undefined;

      var preview = new Parser({
        comments: comments,
        delimiter: delim,
        newline: newline,
        preview: 10
      }).parse(input);

      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }
        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;

        if (typeof fieldCountPrevRow === 'undefined') {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }

      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;

      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }

    _config.delimiter = bestDelim;

    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }

  function guessLineEndings(input, quoteChar) {
    input = input.substr(0, 1024 * 1024); // max length 1 MB
    // Replace all the text inside quotes
    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
    input = input.replace(re, '');

    var r = input.split('\r');

    var n = input.split('\n');

    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;

    if (r.length === 1 || nAppearsFirst) return '\n';

    var numWithN = 0;
    for (var i = 0; i < r.length; i++) {
      if (r[i][0] === '\n') numWithN++;
    }

    return numWithN >= r.length / 2 ? '\r\n' : '\r';
  }

  function addError(type, code, msg, row) {
    _results.errors.push({
      type: type,
      code: code,
      message: msg,
      row: row
    });
  }
}

/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/** The core parser implements speedy and correct CSV parsing */
function Parser(config) {
  // Unpack the config object
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;
  /** Allows for no quoteChar by setting quoteChar to undefined in config */
  if (config.quoteChar === undefined) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }
  var escapeChar = quoteChar;
  if (config.escapeChar !== undefined) {
    escapeChar = config.escapeChar;
  }

  // Delimiter must be valid
  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';

  // Comment character must be valid
  if (comments === delim) throw new Error('Comment character same as delimiter');
  else if (comments === true) comments = '#';
  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
    comments = false;

  // Newline must be valid: \r, \n, or \r\n
  if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';

  // We're gonna need these at the Parser scope
  var cursor = 0;
  var aborted = false;

  this.parse = function(input, baseIndex, ignoreLastRow) {
    // For some reason, in Chrome, this speeds things up (!?)
    if (typeof input !== 'string') throw new Error('Input must be a string');

    // We don't need to compute some of these every time parse() is called,
    // but having them in a more local scope seems to perform better
    var inputLen = input.length,
      delimLen = delim.length,
      newlineLen = newline.length,
      commentsLen = comments.length;
    var stepIsFunction = isFunction(step);

    // Establish starting state
    cursor = 0;
    var data = [],
      errors = [],
      row = [],
      lastCursor = 0;

    if (!input) return returnable();

    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {
      var rows = input.split(newline);
      for (var i = 0; i < rows.length; i++) {
        row = rows[i];
        cursor += row.length;
        if (i !== rows.length - 1) cursor += newline.length;
        else if (ignoreLastRow) return returnable();
        if (comments && row.substr(0, commentsLen) === comments) continue;
        if (stepIsFunction) {
          data = [];
          pushRow(row.split(delim));
          doStep();
          if (aborted) return returnable();
        } else pushRow(row.split(delim));
        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }
      return returnable();
    }

    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
    var quoteSearch;

    // Parser loop
    for (;;) {
      // Field has opening quote
      if (input[cursor] === quoteChar) {
        // Start our search for the closing quote where the cursor is
        quoteSearch = cursor;

        // Skip the opening quote
        cursor++;

        for (;;) {
          // Find closing quote
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

          //No other quotes are found - no other delimiters
          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              // No closing quote... what a pity
              errors.push({
                type: 'Quotes',
                code: 'MissingQuotes',
                message: 'Quoted field unterminated',
                row: data.length, // row has yet to be inserted
                index: cursor
              });
            }
            return finish();
          }

          // Closing quote at EOF
          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }

          // If this quote is escaped, it's part of the data; skip it
          // If the quote character is the escape character, then check if the next character is the escape character
          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }

          // If the quote character is not the escape character, then check if the previous character was the escape character
          if (
            quoteChar !== escapeChar &&
            quoteSearch !== 0 &&
            input[quoteSearch - 1] === escapeChar
          ) {
            continue;
          }

          // Check up to nextDelim or nextNewline, whichever is closest
          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);
            break;
          }

          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

          // Closing quote followed by newline or 'unnecessary spaces + newLine'
          if (
            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline
          ) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
          errors.push({
            type: 'Quotes',
            code: 'InvalidQuotes',
            message: 'Trailing quote on quoted field is malformed',
            row: data.length, // row has yet to be inserted
            index: cursor
          });

          quoteSearch++;
          continue;
        }

        continue;
      }

      // Comment found at start of new line
      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1)
          // Comment ends at EOF
          return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // Next delimiter comes before next newline, so we've reached end of field
      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // End of row
      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);

        continue;
      }

      break;
    }

    return finish();

    function pushRow(row) {
      data.push(row);
      lastCursor = cursor;
    }

    /**
     * checks if there are extra spaces after closing quote and given index without any text
     * if Yes, returns the number of spaces
     */
    function extraSpaces(index) {
      var spaceLength = 0;
      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }
      return spaceLength;
    }

    /**
     * Appends the remaining input from cursor to the end into
     * row, saves the row, calls step, and returns the results.
     */
    function finish(value) {
      if (ignoreLastRow) return returnable();
      if (typeof value === 'undefined') value = input.substr(cursor);
      row.push(value);
      cursor = inputLen; // important in case parsing is paused
      pushRow(row);
      if (stepIsFunction) doStep();
      return returnable();
    }

    /**
     * Appends the current row to the results. It sets the cursor
     * to newCursor and finds the nextNewline. The caller should
     * take care to execute user's step function and check for
     * preview and end parsing if necessary.
     */
    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }

    /** Returns an object with the results, errors, and meta. */
    function returnable(stopped, step) {
      var isStep = step || false;
      return {
        data: isStep ? data[0] : data,
        errors: errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted: aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }

    /** Executes the user's step function and resets data & errors. */
    function doStep() {
      step(returnable(undefined, true));
      data = [];
      errors = [];
    }
  };

  /** Sets the abort flag */
  this.abort = function() {
    aborted = true;
  };

  /** Gets the cursor position */
  this.getCharIndex = function() {
    return cursor;
  };
}

/*
function getWorkerBlob() {
	var URL = global.URL || global.webkitURL || null;
	var code = moduleFactory.toString();
	return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));
}

var IS_WORKER = !global.document && !!global.postMessage,
	IS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);
var workers = {}, workerIdCounter = 0;

function newWorker()
{
	if (!Papa.WORKERS_SUPPORTED)
		return false;

	var workerUrl = getWorkerBlob();
	var w = new global.Worker(workerUrl);
	w.onmessage = mainThreadReceivedMessage;
	w.id = workerIdCounter++;
	workers[w.id] = w;
	return w;
}

// Callback when main thread receives a message
function mainThreadReceivedMessage(e)
{
	var msg = e.data;
	var worker = workers[msg.workerId];
	var aborted = false;

	if (msg.error)
		worker.userError(msg.error, msg.file);
	else if (msg.results && msg.results.data)
	{
		var abort = function() {
			aborted = true;
			completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
		};

		var handle = {
			abort: abort,
			pause: notImplemented,
			resume: notImplemented
		};

		if (isFunction(worker.userStep))
		{
			for (var i = 0; i < msg.results.data.length; i++)
			{
				worker.userStep({
					data: msg.results.data[i],
					errors: msg.results.errors,
					meta: msg.results.meta
				}, handle);
				if (aborted)
					break;
			}
			delete msg.results;	// free memory ASAP
		}
		else if (isFunction(worker.userChunk))
		{
			worker.userChunk(msg.results, handle, msg.file);
			delete msg.results;
		}
	}

	if (msg.finished && !aborted)
		completeWorker(msg.workerId, msg.results);
}

function completeWorker(workerId, results) {
	var worker = workers[workerId];
	if (isFunction(worker.userComplete))
		worker.userComplete(results);
	worker.terminate();
	delete workers[workerId];
}

// Callback when worker thread receives a message
function workerThreadReceivedMessage(e)
{
	var msg = e.data;

	if (typeof Papa.WORKER_ID === 'undefined' && msg)
		Papa.WORKER_ID = msg.workerId;

	if (typeof msg.input === 'string')
	{
		global.postMessage({
			workerId: Papa.WORKER_ID,
			results: Papa.parse(msg.input, msg.config),
			finished: true
		});
	}
	else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
	{
		var results = Papa.parse(msg.input, msg.config);
		if (results)
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: results,
				finished: true
			});
	}
}
*/

function notImplemented() {
  throw new Error('Not implemented.');
}

/** Makes a deep copy of an array or object (mostly) */
function copy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  var cpy = Array.isArray(obj) ? [] : {};
  for (var key in obj) cpy[key] = copy(obj[key]);
  return cpy;
}

function bindFunction(f, self) {
  return function() {
    f.apply(self, arguments);
  };
}

function isFunction(func) {
  return typeof func === 'function';
}


/***/ })

/******/ });
});