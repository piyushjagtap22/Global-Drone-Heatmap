{"version":3,"sources":["../../../src/lib/async-iterator-streamer.js"],"names":["Papa","ChunkStreamer","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","asyncIterator","_input","chunk","parseChunk","getStringChunk","_finished","error","_sendError","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"mappings":"AASA,OAAOA,IAAP,MAAiB,mBAAjB;AACA,MAAM;AAACC,EAAAA;AAAD,IAAkBD,IAAxB;AAEA,eAAe,SAASE,qBAAT,CAA+BC,MAA/B,EAAuC;AACpDA,EAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AAEAF,EAAAA,aAAa,CAACG,IAAd,CAAmB,IAAnB,EAAyBD,MAAzB;AAEA,OAAKE,WAAL,GAAmB,IAAIC,WAAJ,CAAgB,KAAKC,OAAL,CAAaC,QAA7B,CAAnB;;AAaA,OAAKC,MAAL,GAAc,gBAAeC,aAAf,EAA8B;AAC1C,SAAKC,MAAL,GAAcD,aAAd;;AAEA,QAAI;AAGF,iBAAW,MAAME,KAAjB,IAA0BF,aAA1B,EAAyC;AACvC,aAAKG,UAAL,CAAgB,KAAKC,cAAL,CAAoBF,KAApB,CAAhB;AACD;;AAcD,WAAKG,SAAL,GAAiB,IAAjB;AACA,WAAKF,UAAL,CAAgB,EAAhB;AACD,KArBD,CAqBE,OAAOG,KAAP,EAAc;AAEd,WAAKC,UAAL,CAAgBD,KAAhB;AACD;AACF,GA5BD;;AA8BA,OAAKE,UAAL,GAAkB,SAASC,SAAT,GAAqB,CAEtC,CAFD;;AAKA,OAAKL,cAAL,GAAsB,UAASF,KAAT,EAAgB;AACpC,WAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,KAAKP,WAAL,CAAiBe,MAAjB,CAAwBR,KAAxB,EAA+B;AAACH,MAAAA,MAAM,EAAE;AAAT,KAA/B,CAA3C;AACD,GAFD;AAGD;AAEDP,qBAAqB,CAACmB,SAAtB,GAAkCC,MAAM,CAACC,MAAP,CAActB,aAAa,CAACoB,SAA5B,CAAlC;AACAnB,qBAAqB,CAACmB,SAAtB,CAAgCG,WAAhC,GAA8CtB,qBAA9C","sourcesContent":["// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n// @ts-nocheck\n/* eslint-disable no-invalid-this */\n/* global TextDecoder */\n\n// Note: papaparse is not an ES6 module\nimport Papa from '../libs/papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function(asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function(chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"],"file":"async-iterator-streamer.js"}