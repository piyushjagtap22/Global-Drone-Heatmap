import { AsyncQueue, TableBatchBuilder, RowTableBatch } from '@loaders.gl/tables';
import Papa from './libs/papaparse';
import AsyncIteratorStreamer from './lib/async-iterator-streamer';
const VERSION = typeof "2.3.13" !== 'undefined' ? "2.3.13" : 'latest';
const CSVLoaderOptions = {
  csv: {
    TableBatch: RowTableBatch,
    batchSize: 10,
    optimizeMemoryUsage: false,
    header: 'auto',
    rowFormat: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: false,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
export default {
  id: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),
  parseText: parseCSV,
  parseInBatches: parseCSVInBatches,
  testText: null,
  options: CSVLoaderOptions
};

async function parseCSV(csvText, options) {
  options = { ...CSVLoaderOptions,
    ...options
  };
  options.csv = { ...CSVLoaderOptions.csv,
    ...options.csv
  };
  const header = await hasHeader(csvText, options);
  const config = {
    dynamicTyping: true,
    ...options.csv,
    header,
    download: false,
    error: e => {
      throw new Error(e);
    }
  };
  const result = Papa.parse(csvText, config);
  return result.data;
}

function parseCSVInBatches(asyncIterator, options) {
  options = { ...CSVLoaderOptions,
    ...options
  };
  options.csv = { ...CSVLoaderOptions.csv,
    ...options.csv
  };
  const {
    batchSize,
    optimizeMemoryUsage
  } = options.csv;
  const TableBatchType = options.csv.TableBatch;
  const asyncQueue = new AsyncQueue();
  const convertToObject = options.csv.rowFormat === 'object';
  let isFirstRow = true;
  let headerRow = null;
  let tableBatchBuilder = null;
  let schema = null;
  const config = {
    dynamicTyping: true,
    ...options.csv,
    header: false,
    download: false,

    step(results, parser) {
      const row = results.data;
      const bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        const header = isHeaderRow(row, options);

        if (header) {
          headerRow = row;
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = [];

          for (let i = 0; i < row.length; i++) {
            headerRow[i] = "".concat(options.csv.columnPrefix).concat(i + 1);
          }
        }

        schema = deduceSchema(row, headerRow);
      }

      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {
        batchSize,
        convertToObject,
        optimizeMemoryUsage
      });
      tableBatchBuilder.addRow(row);

      if (tableBatchBuilder.isFull()) {
        asyncQueue.enqueue(tableBatchBuilder.getBatch({
          bytesUsed
        }));
      }
    },

    complete(results, file) {
      const bytesUsed = results.meta.cursor;
      const batch = tableBatchBuilder.getBatch({
        bytesUsed
      });

      if (batch) {
        asyncQueue.enqueue(batch);
      }

      asyncQueue.close();
    }

  };
  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);
  return asyncQueue;
}

function isHeaderRow(row, options) {
  if (options && options.csv.header !== 'auto') {
    return Boolean(options.csv.header);
  }

  return row.every(value => typeof value === 'string');
}

async function hasHeader(csvText, options) {
  if (options.csv.header !== 'auto') {
    return Boolean(options.csv.header);
  }

  return await new Promise((resolve, reject) => {
    Papa.parse(csvText, {
      download: false,
      dynamicTyping: true,
      step: (results, parser) => {
        parser.abort();
        const row = results.data;
        resolve(isHeaderRow(row));
      },
      error: e => {
        reject(new Error(e));
      }
    });
  });
}

function deduceSchema(row, headerRow) {
  const schema = headerRow ? {} : [];

  for (let i = 0; i < row.length; i++) {
    const columnName = headerRow && headerRow[i] || i;
    const value = row[i];

    switch (typeof value) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}
//# sourceMappingURL=csv-loader.js.map