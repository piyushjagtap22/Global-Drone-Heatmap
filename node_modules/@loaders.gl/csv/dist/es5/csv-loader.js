"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tables = require("@loaders.gl/tables");

var _papaparse = _interopRequireDefault(require("./libs/papaparse"));

var _asyncIteratorStreamer = _interopRequireDefault(require("./lib/async-iterator-streamer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var VERSION = typeof "2.3.13" !== 'undefined' ? "2.3.13" : 'latest';
var CSVLoaderOptions = {
  csv: {
    TableBatch: _tables.RowTableBatch,
    batchSize: 10,
    optimizeMemoryUsage: false,
    header: 'auto',
    rowFormat: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: false,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
var _default = {
  id: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: function () {
    var _parse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(arrayBuffer, options) {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseCSV(new TextDecoder().decode(arrayBuffer), options));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x, _x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseText: parseCSV,
  parseInBatches: parseCSVInBatches,
  testText: null,
  options: CSVLoaderOptions
};
exports["default"] = _default;

function parseCSV(_x3, _x4) {
  return _parseCSV.apply(this, arguments);
}

function _parseCSV() {
  _parseCSV = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(csvText, options) {
    var header, config, result;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);
            options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);
            _context2.next = 4;
            return hasHeader(csvText, options);

          case 4:
            header = _context2.sent;
            config = _objectSpread(_objectSpread({
              dynamicTyping: true
            }, options.csv), {}, {
              header: header,
              download: false,
              error: function error(e) {
                throw new Error(e);
              }
            });
            result = _papaparse["default"].parse(csvText, config);
            return _context2.abrupt("return", result.data);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseCSV.apply(this, arguments);
}

function parseCSVInBatches(asyncIterator, options) {
  options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);
  options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);
  var _options$csv = options.csv,
      batchSize = _options$csv.batchSize,
      optimizeMemoryUsage = _options$csv.optimizeMemoryUsage;
  var TableBatchType = options.csv.TableBatch;
  var asyncQueue = new _tables.AsyncQueue();
  var convertToObject = options.csv.rowFormat === 'object';
  var isFirstRow = true;
  var headerRow = null;
  var tableBatchBuilder = null;
  var schema = null;

  var config = _objectSpread(_objectSpread({
    dynamicTyping: true
  }, options.csv), {}, {
    header: false,
    download: false,
    step: function step(results, parser) {
      var row = results.data;
      var bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        var header = isHeaderRow(row, options);

        if (header) {
          headerRow = row;
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = [];

          for (var i = 0; i < row.length; i++) {
            headerRow[i] = "".concat(options.csv.columnPrefix).concat(i + 1);
          }
        }

        schema = deduceSchema(row, headerRow);
      }

      tableBatchBuilder = tableBatchBuilder || new _tables.TableBatchBuilder(TableBatchType, schema, {
        batchSize: batchSize,
        convertToObject: convertToObject,
        optimizeMemoryUsage: optimizeMemoryUsage
      });
      tableBatchBuilder.addRow(row);

      if (tableBatchBuilder.isFull()) {
        asyncQueue.enqueue(tableBatchBuilder.getBatch({
          bytesUsed: bytesUsed
        }));
      }
    },
    complete: function complete(results, file) {
      var bytesUsed = results.meta.cursor;
      var batch = tableBatchBuilder.getBatch({
        bytesUsed: bytesUsed
      });

      if (batch) {
        asyncQueue.enqueue(batch);
      }

      asyncQueue.close();
    }
  });

  _papaparse["default"].parse(asyncIterator, config, _asyncIteratorStreamer["default"]);

  return asyncQueue;
}

function isHeaderRow(row, options) {
  if (options && options.csv.header !== 'auto') {
    return Boolean(options.csv.header);
  }

  return row.every(function (value) {
    return typeof value === 'string';
  });
}

function hasHeader(_x5, _x6) {
  return _hasHeader.apply(this, arguments);
}

function _hasHeader() {
  _hasHeader = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(csvText, options) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(options.csv.header !== 'auto')) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt("return", Boolean(options.csv.header));

          case 2:
            _context3.next = 4;
            return new Promise(function (resolve, reject) {
              _papaparse["default"].parse(csvText, {
                download: false,
                dynamicTyping: true,
                step: function step(results, parser) {
                  parser.abort();
                  var row = results.data;
                  resolve(isHeaderRow(row));
                },
                error: function error(e) {
                  reject(new Error(e));
                }
              });
            });

          case 4:
            return _context3.abrupt("return", _context3.sent);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _hasHeader.apply(this, arguments);
}

function deduceSchema(row, headerRow) {
  var schema = headerRow ? {} : [];

  for (var i = 0; i < row.length; i++) {
    var columnName = headerRow && headerRow[i] || i;
    var value = row[i];

    switch ((0, _typeof2["default"])(value)) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}
//# sourceMappingURL=csv-loader.js.map